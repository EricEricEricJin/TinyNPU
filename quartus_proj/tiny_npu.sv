
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module tiny_npu(

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HPS //////////
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW
);


////////////////////////
// Parameters
////////////////////////
localparam int SDRAM_W = 128;

////////////////////////
// Clock and reset 
////////////////////////

logic h2f_rst_n;
logic clk;
logic rst_n;

assign clk = FPGA_CLK1_50;
assign rst_n = h2f_rst_n & KEY[0];


logic [31 : 0] f2h_pio32, h2f_pio32;
logic f2h_read, h2f_write;

sdram_intf i_sdram_intf_bi_0 ();
sdram_read_intf i_sdram_intf_read_0 ();

////////////////////////
// SoC
////////////////////////
soc_system u0 (
    .clk_clk                  (clk),                  //        clk.clk
    .reset_reset_n            (rst_n),            //      reset.reset_n
	.h2f_reset_reset_n        (h2f_rst_n),        //  h2f_reset.reset_n
	
	// -------------------- MMIO between HPS and FPGA --------------------
	.f2h_pio32_en_out         (f2h_read),         //  f2h_pio32.en_out
	.f2h_pio32_data_in        (f2h_pio32),        //           .data_in
	.h2f_pio32_en_out         (h2f_write),         //  h2f_pio32.en_out
	.h2f_pio32_data_out       (h2f_pio32),       //           .data_out

	// -------------------- SDRAM Read --------------------
	.avmm_sdram_read_wrapper_0_read_read_start (i_sdram_intf_read_0.read_start), // avmm_sdram_read_wrapper_0_read.read_start
	.avmm_sdram_read_wrapper_0_read_read_cnt   (i_sdram_intf_read_0.read_cnt),   //                               .read_cnt
	.avmm_sdram_read_wrapper_0_read_read_data  (i_sdram_intf_read_0.read_data),  //                               .read_data
	.avmm_sdram_read_wrapper_0_read_read_addr  (i_sdram_intf_read_0.read_addr),  //                               .read_addr
	.avmm_sdram_read_wrapper_0_read_read_done  (i_sdram_intf_read_0.read_done),  //                               .read_done
	.avmm_sdram_read_wrapper_0_read_read_valid (i_sdram_intf_read_0.read_valid), //  							  .read_valid

	// -------------------- SDRAM Bidirectional --------------------
	.avmm_sdram_wrapper_0_read_read_start   (i_sdram_intf_bi_0.read_start),   //  avmm_sdram_wrapper_0_read.read_start
	.avmm_sdram_wrapper_0_read_read_data    (i_sdram_intf_bi_0.read_data),    //                           .read_data
	.avmm_sdram_wrapper_0_read_read_valid   (i_sdram_intf_bi_0.read_valid),   //                           .read_valid

	.avmm_sdram_wrapper_0_rw_rw_cnt         (i_sdram_intf_bi_0.rw_cnt),         //    avmm_sdram_wrapper_0_rw.rw_cnt
	.avmm_sdram_wrapper_0_rw_rw_done        (i_sdram_intf_bi_0.rw_done),        //                           .rw_done
	.avmm_sdram_wrapper_0_rw_rw_addr        (i_sdram_intf_bi_0.rw_addr),        //                           .rw_addr

	.avmm_sdram_wrapper_0_write_write_data  (i_sdram_intf_bi_0.write_data),  // avmm_sdram_wrapper_0_write.write_data
	.avmm_sdram_wrapper_0_write_write_nxt   (i_sdram_intf_bi_0.write_nxt),   //                           .write_nxt
	.avmm_sdram_wrapper_0_write_write_start (i_sdram_intf_bi_0.write_start), //   

	// -------------------- DDR3 Interface --------------------
    .memory_mem_a            (HPS_DDR3_ADDR),            //          memory.mem_a
    .memory_mem_ba           (HPS_DDR3_BA),           //                .mem_ba
    .memory_mem_ck           (HPS_DDR3_CK_P),           //                .mem_ck
    .memory_mem_ck_n         (HPS_DDR3_CK_N),         //                .mem_ck_n
    .memory_mem_cke          (HPS_DDR3_CKE),          //                .mem_cke
    .memory_mem_cs_n         (HPS_DDR3_CS_N),         //                .mem_cs_n
    .memory_mem_ras_n        (HPS_DDR3_RAS_N),        //                .mem_ras_n
    .memory_mem_cas_n        (HPS_DDR3_CAS_N),        //                .mem_cas_n
    .memory_mem_we_n         (HPS_DDR3_WE_N),         //                .mem_we_n
    .memory_mem_reset_n      (HPS_DDR3_RESET_N),      //                .mem_reset_n
    .memory_mem_dq           (HPS_DDR3_DQ),           //                .mem_dq
    .memory_mem_dqs          (HPS_DDR3_DQS_P),          //                .mem_dqs
    .memory_mem_dqs_n        (HPS_DDR3_DQS_N),        //                .mem_dqs_n
    .memory_mem_odt          (HPS_DDR3_ODT),          //                .mem_odt
    .memory_mem_dm           (HPS_DDR3_DM),           //                .mem_dm
    .memory_oct_rzqin        (HPS_DDR3_RZQ),        //                .oct_rzqin
);


////////////////////////
// Design Top
////////////////////////
design_top i_design_top (
    .clk            (clk),   
    .rst_n          (rst_n),

    .i_sdram_intf   (i_sdram_intf_bi_0.ldst),
	.i_sdram_read_intf (i_sdram_intf_read_0.fetch),
    
    .h2f_pio32      (h2f_pio32),
    .h2f_write      (h2f_write),
    
    .f2h_pio32      (f2h_pio32),
    .f2h_write      (f2h_write)
);

////////////////////////
// counter to test alive
////////////////////////
logic [31 : 0] blink_cnt;
logic [7 : 0] blink_leds;
always_ff @( posedge clk, negedge rst_n ) begin
	if (!rst_n) begin
		blink_leds <= 8'b1;
		blink_cnt <= '0;
	end
	else if (blink_cnt == 32'd49_999_999) begin
		blink_leds <= {blink_leds[6 : 0], blink_leds[7]};
		blink_cnt <= '0;
	end
	else begin
		blink_cnt <= blink_cnt + 32'd1;
	end
end
assign LED = blink_leds;

endmodule
