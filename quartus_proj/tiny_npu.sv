
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module tiny_npu(

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HPS //////////
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW
);


////////////////////////
// Parameters
////////////////////////
localparam int SDRAM_W = 128;

////////////////////////
// Clock and reset 
////////////////////////

// clock and reset from external circuit
logic ext_clk;
logic h2f_rst_n;
logic ext_rst_n;
assign ext_clk = FPGA_CLK1_50;
assign ext_rst_n = h2f_rst_n & KEY[0];

// system clk and rst_n
logic clk;		// PLLed clock, 400MHz	
logic rst_n;	// DUT reset_n
logic pll_locked;

assign rst_n = ext_rst_n & pll_locked;


logic [31 : 0] f2h_pio32, h2f_pio32;
logic f2h_read, h2f_write;

sdram_intf i_sdram_intf_bi_0 ();

////////////////////////
// SoC
////////////////////////
soc_system u0 (
	.ext_clk_clk              (ext_clk),              //    ext_clk.clk
	.ext_rst_reset_n          (ext_rst_n),          //    ext_rst.reset_n
	
	.f2h_pio32_en_out         (f2h_read),         //  f2h_pio32.en_out
	.f2h_pio32_data_in        (f2h_pio32),        //           .data_in
	
	.f2h_sdram0_address       (i_sdram_intf_bi_0.address),       // f2h_sdram0.address
	.f2h_sdram0_burstcount    (i_sdram_intf_bi_0.burstcount),    //           .burstcount
	.f2h_sdram0_waitrequest   (i_sdram_intf_bi_0.waitrequest),   //           .waitrequest
	.f2h_sdram0_readdata      (i_sdram_intf_bi_0.readdata),      //           .readdata
	.f2h_sdram0_readdatavalid (i_sdram_intf_bi_0.readdatavalid), //           .readdatavalid
	.f2h_sdram0_read          (i_sdram_intf_bi_0.read),          //           .read
	.f2h_sdram0_writedata     (i_sdram_intf_bi_0.writedata),     //           .writedata
	.f2h_sdram0_byteenable    (i_sdram_intf_bi_0.byteenable),    //           .byteenable
	.f2h_sdram0_write         (i_sdram_intf_bi_0.write),         //           .write
	
	.h2f_pio32_en_out         (h2f_write),         //  h2f_pio32.en_out
	.h2f_pio32_data_out       (h2f_pio32),       //           .data_out
	
	.h2f_reset_reset_n        (h2f_rst_n),        //  h2f_reset.reset_n
	
    .memory_mem_a            (HPS_DDR3_ADDR),            //          memory.mem_a
    .memory_mem_ba           (HPS_DDR3_BA),           //                .mem_ba
    .memory_mem_ck           (HPS_DDR3_CK_P),           //                .mem_ck
    .memory_mem_ck_n         (HPS_DDR3_CK_N),         //                .mem_ck_n
    .memory_mem_cke          (HPS_DDR3_CKE),          //                .mem_cke
    .memory_mem_cs_n         (HPS_DDR3_CS_N),         //                .mem_cs_n
    .memory_mem_ras_n        (HPS_DDR3_RAS_N),        //                .mem_ras_n
    .memory_mem_cas_n        (HPS_DDR3_CAS_N),        //                .mem_cas_n
    .memory_mem_we_n         (HPS_DDR3_WE_N),         //                .mem_we_n
    .memory_mem_reset_n      (HPS_DDR3_RESET_N),      //                .mem_reset_n
    .memory_mem_dq           (HPS_DDR3_DQ),           //                .mem_dq
    .memory_mem_dqs          (HPS_DDR3_DQS_P),          //                .mem_dqs
    .memory_mem_dqs_n        (HPS_DDR3_DQS_N),        //                .mem_dqs_n
    .memory_mem_odt          (HPS_DDR3_ODT),          //                .mem_odt
    .memory_mem_dm           (HPS_DDR3_DM),           //                .mem_dm
    .memory_oct_rzqin        (HPS_DDR3_RZQ),        //                .oct_rzqin
    
	.pll_locked_export        (pll_locked),        // pll_locked.export
	
	.sys_clk_clk              (clk),              //    sys_clk.clk
	.sys_rst_reset_n          (rst_n)           //    sys_rst.reset_n
);


////////////////////////
// Design Top
////////////////////////
design_top i_design_top (
    .clk            (clk),   
    .rst_n          (rst_n),

    .i_sdram_intf   (i_sdram_intf_bi_0.ldst),
    
    .h2f_pio32      (h2f_pio32),
    .h2f_write      (h2f_write),
    
    .f2h_pio32      (f2h_pio32),
    .f2h_write      (f2h_write)
);

////////////////////////
// counter to test alive
////////////////////////
logic [31 : 0] blink_cnt;
logic [7 : 0] blink_leds;
always_ff @( posedge clk, negedge rst_n ) begin
	if (!rst_n) begin
		blink_leds <= 8'b1;
		blink_cnt <= '0;
	end
	else if (blink_cnt == 32'd399_999_999) begin
		blink_leds <= {blink_leds[6 : 0], blink_leds[7]};
		blink_cnt <= '0;
	end
	else begin
		blink_cnt <= blink_cnt + 32'd1;
	end
end
assign LED = blink_leds;

endmodule
