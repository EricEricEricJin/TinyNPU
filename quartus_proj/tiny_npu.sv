
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module tiny_npu(

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HPS //////////
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW
);


////////////////////////
// Parameters
////////////////////////
localparam int SDRAM_W = 128;

////////////////////////
// Clock and reset 
////////////////////////

// clock and reset from external circuit
logic ext_clk;
logic h2f_rst_n;
logic ext_rst_n;
assign ext_clk = FPGA_CLK1_50;
assign ext_rst_n = h2f_rst_n & KEY[0];

// system clk and rst_n
logic clk;		// PLLed clock, 400MHz	
logic rst_n;	// DUT reset_n
logic pll_locked;

assign rst_n = ext_rst_n & pll_locked;


////////////////////////
// SoC
////////////////////////
// logic [31 : 0]	sdram_address;
// logic [10 : 0]	sdram_burstcnt;
// logic sdram_waitreq;
// logic sdram_readstart;
// logic sdram_readvalid;
// logic [SDRAM_W - 1 : 0] sdram_readdata;

logic [31 : 0] f2h_pio32, h2f_pio32;

sdram_read_wrapper_intf #( .SDRAM_W (SDRAM_W) ) i_sdram_read_wrapper_intf();
sdram_read_intf         #( .SDRAM_W (SDRAM_W) )	i_sdram_read_intf();

// new
soc_system u0 (
	// AVMM F2H
	.f2h_pio32_en_out         (),         //  f2h_pio32.en_out
	.f2h_pio32_data_in        (f2h_pio32),         //           .data_in

	// AVMM H2F
	.h2f_pio32_en_out         (),         //  h2f_pio32.en_out
	.h2f_pio32_data_out       (h2f_pio32),       //           .data_out
	
	// connect to SDRAM master 
	// .f2h_sdram0_address       (sdram_address),       // f2h_sdram0.address
	// .f2h_sdram0_burstcount    (sdram_burstcnt),    //           .burstcount
	// .f2h_sdram0_waitrequest   (sdram_waitreq),   //           .waitrequest
	// .f2h_sdram0_readdata      (sdram_readdata),      //           .readdata
	// .f2h_sdram0_readdatavalid (sdram_readvalid), //           .readdatavalid
	// .f2h_sdram0_read          (sdram_readstart),          //           .read

	.f2h_sdram0_address       (i_sdram_read_intf.address),       // f2h_sdram0.address
	.f2h_sdram0_burstcount    (i_sdram_read_intf.burstcount),    //           .burstcount
	.f2h_sdram0_waitrequest   (i_sdram_read_intf.waitrequest),   //           .waitrequest
	.f2h_sdram0_readdata      (i_sdram_read_intf.readdata),      //           .readdata
	.f2h_sdram0_readdatavalid (i_sdram_read_intf.readdatavalid), //           .readdatavalid
	.f2h_sdram0_read          (i_sdram_read_intf.read),          //           .read

	.h2f_reset_reset_n        (h2f_rst_n),        //  h2f_reset.reset_n
	
	// Connect to DDR3
    .memory_mem_a            (HPS_DDR3_ADDR),           //          memory.mem_a
    .memory_mem_ba           (HPS_DDR3_BA),           	//                .mem_ba
    .memory_mem_ck           (HPS_DDR3_CK_P),           //                .mem_ck
    .memory_mem_ck_n         (HPS_DDR3_CK_N),         	//                .mem_ck_n
    .memory_mem_cke          (HPS_DDR3_CKE),          	//                .mem_cke
    .memory_mem_cs_n         (HPS_DDR3_CS_N),         	//                .mem_cs_n
    .memory_mem_ras_n        (HPS_DDR3_RAS_N),        	//                .mem_ras_n
    .memory_mem_cas_n        (HPS_DDR3_CAS_N),        	//                .mem_cas_n
    .memory_mem_we_n         (HPS_DDR3_WE_N),         	//                .mem_we_n
    .memory_mem_reset_n      (HPS_DDR3_RESET_N),      	//                .mem_reset_n
    .memory_mem_dq           (HPS_DDR3_DQ),           	//                .mem_dq
    .memory_mem_dqs          (HPS_DDR3_DQS_P),          //                .mem_dqs
    .memory_mem_dqs_n        (HPS_DDR3_DQS_N),        	//                .mem_dqs_n
    .memory_mem_odt          (HPS_DDR3_ODT),          	//                .mem_odt
    .memory_mem_dm           (HPS_DDR3_DM),           	//                .mem_dm
    .memory_oct_rzqin        (HPS_DDR3_RZQ),        	//                .oct_rzqin
	
	.ext_rst_reset_n          (ext_rst_n),          //    ext_rst.reset_n
	.ext_clk_clk              (ext_clk),              //    ext_clk.clk
	
	.pll_locked_export        (pll_locked),        // pll_locked.export
	
	.sys_clk_clk              (clk),              //    sys_clk.clk
	.sys_rst_reset_n          (rst_n)             //    sys_rst.reset_n
);

// sdram_read
sdram_read #(.SDRAM_W (SDRAM_W)) i_sdram_read (
	.clk			(clk),
	.rst_n			(rst_n),

	// .readdata		(sdram_readdata),
	// .readdatavalid	(sdram_readvalid),
	// .waitrequest	(sdram_waitreq),
	// .read			(sdram_readstart),
	// .address		(sdram_address),
	// .burstcount		(sdram_burstcnt),
	.avalon_intf	(i_sdram_read_intf.master),

	// .read_addr		(),
	// .read_cnt		(),
	// .read_start		(1'b0),
	// .out_valid		(),
	// .out_idx		(),
	// .out_data		()
	.wrapper_intf	(i_sdram_read_wrapper_intf.slave)
);

////////////////////////
// Connect to DUT
////////////////////////
design_top i_design_top (
	.clk			(clk),
	.rst_n			(rst_n),
	
	.mem_read_intf	(i_sdram_read_wrapper_intf.master),
	
	.h2f_pio32		(h2f_pio32),
	.f2h_pio32		(f2h_pio32)
);


// counter to test clk and rst_n
logic [31 : 0] blink_cnt;
logic [7 : 0] blink_leds;
always_ff @( posedge clk, negedge rst_n ) begin
	if (!rst_n) begin
		blink_leds <= 8'b1;
		blink_cnt <= '0;
	end
	else if (blink_cnt == 32'd399_999_999) begin
		blink_leds <= {blink_leds[6 : 0], blink_leds[7]};
		blink_cnt <= '0;
	end
	else begin
		blink_cnt <= blink_cnt + 32'd1;
	end
end
assign LED = blink_leds;

endmodule